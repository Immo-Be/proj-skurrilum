---
interface Props {
  headline: string;
  subheadline: string;
  typingSpeed?: number;
  cursorDelay?: number;
  headingLevel?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
  subheadingLevel?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
}

const {
  headline = "", 
  subheadline = "",
  typingSpeed = 100, 
  cursorDelay = 500,
  headingLevel = 'h1',
  subheadingLevel = 'h2'
} = Astro.props as Props;

// Process the subheadline into parts if it has more than 3 words
const subheadlineWords = subheadline.trim().split(/\s+/);
let subheadlineParts: string[] = [];

if (subheadlineWords.length <= 3) {
  subheadlineParts = [subheadline];
} else {
  // Split as equally as possible into two parts
  const midpoint = Math.ceil(subheadlineWords.length / 2);
  const firstPart = subheadlineWords.slice(0, midpoint).join(" ");
  const secondPart = subheadlineWords.slice(midpoint).join(" ");
  subheadlineParts = [firstPart, secondPart];
}

// Create the sequence of phrases to type
const sequenceToType = [headline, ...subheadlineParts];

// Final sequence to display without erasing
const finalDisplay = {
  heading: headline,
  subheading: subheadline
};
---

<div
  class="typewriter-container min-h-[8rem] flex flex-col items-center justify-center"
  aria-live="polite"
  aria-atomic="true"
  aria-relevant="additions text"
  role="region"
  aria-roledescription="animated headline"
>
  {/* Visible animated element */}
  <div
    class="text-step-5 sm:text-step-6 md:text-step-8 mt-4 w-fit text-center font-bold leading-tight tracking-tight typewriter-text"
    id="typewriter-animation"
    data-sequence={JSON.stringify(sequenceToType)}
    data-final-heading={headline}
    data-final-subheading={subheadline}
    data-typing-speed={typingSpeed}
    data-cursor-delay={cursorDelay}

    role="presentation"
    aria-hidden="true"
  >
  <span class="typewriter-content text-4xl lg:text-6xl text-center"></span><span class="typewriter-cursor text-4xl lg:text-6xl" aria-hidden="true">|</span>
  </div>
  
  {/* Hidden headings for SEO and screen readers */}
  <div class="sr-only" id="static-headlines">
    {/* The main heading */}
    {(() => {
      const HeadingTag = headingLevel;
      return <HeadingTag id="main-heading">{headline}</HeadingTag>;
    })()}
    
    {/* The subheading */}
    {(() => {
      const SubheadingTag = subheadingLevel;
      return <SubheadingTag id="main-subheading">{subheadline}</SubheadingTag>;
    })()}
  </div>
  
  {/* Visually hidden but announced to screen readers as content changes */}
  <div class="sr-only" aria-live="assertive" id="active-content" role="status"></div>
  
  {/* We don't need a separate final display container anymore since we're typing it directly */}
  <div id="final-display" class="hidden">
    {/* Content will be generated by JavaScript */}
  </div>
</div>

<script>
  document.addEventListener('astro:page-load', () => {
    const typewriterElements = document.querySelectorAll('.typewriter-text');
    
    typewriterElements.forEach(element => {
      const sequence = JSON.parse(element.getAttribute('data-sequence') || '[""]');
      const finalHeading = element.getAttribute('data-final-heading') || '';
      const finalSubheading = element.getAttribute('data-final-subheading') || '';
      const typingSpeed = parseInt(element.getAttribute('data-typing-speed') || '100');
      const cursorDelay = parseInt(element.getAttribute('data-cursor-delay') || '500');
      const pauseBetweenParts = 1000; // Pause between different parts
      
      let currentSequenceIndex = 0;
      let currentText = sequence[currentSequenceIndex];
      
      const contentElement = element.querySelector('.typewriter-content');
      const cursorElement = element.querySelector('.typewriter-cursor');
      const containerElement = element.closest('.typewriter-container');
      const activeContentElement = containerElement?.querySelector('#active-content');
      const finalDisplayElement = containerElement?.querySelector('#final-display');
      
      if (contentElement && cursorElement && currentText && containerElement && activeContentElement && finalDisplayElement) {
        let charIndex = 0;

        let isAnimating = false;
        let animationComplete = false;
        
        // Start blinking cursor
        const cursorBlinkInterval = setInterval(() => {
          if (!animationComplete) {
            cursorElement.style.opacity = cursorElement.style.opacity === '0' ? '1' : '0';
          } else {
            cursorElement.style.opacity = '0'; // Hide cursor when animation is complete
            clearInterval(cursorBlinkInterval);
          }
        }, cursorDelay);
        
        // Update ARIA attributes for accessibility
        const updateAriaLabel = () => {
          // Update active content for screen readers
          activeContentElement.textContent = `Current text: ${currentText}`;
          
          // Set focus to the content for screen readers if not already animating
          if (!isAnimating) {
            isAnimating = true;
            
            // Using a timeout to avoid too frequent announcements
            setTimeout(() => {
              activeContentElement.textContent = `Now displaying: ${currentText}`;
            }, 100);
          }
        };
        
        // Type characters forward
        const typeNextChar = () => {
          if (charIndex < currentText.length) {
            contentElement.textContent += currentText.charAt(charIndex);
            charIndex++;
            setTimeout(typeNextChar, typingSpeed);
          } else {
            // When typing this part is complete
            if (currentSequenceIndex < sequence.length - 1) {
              // Move to the next part after a pause, without erasing
              setTimeout(() => {
                contentElement.textContent += " "; // Add a space between parts
                currentSequenceIndex++;
                currentText = sequence[currentSequenceIndex];
                charIndex = 0;
                isAnimating = false; // Reset animation state
                updateAriaLabel(); // Update ARIA label when changing text
                typeNextChar();
              }, pauseBetweenParts);
            } else {
              // This was the last part of the sequence, show the final display
              // Add a small delay for a natural pause
              setTimeout(showFinalDisplay, pauseBetweenParts);
            }
          }
        };
        
        // Keeping this function for compatibility but it won't be called in the new flow
        const eraseText = () => {
          // This function is no longer used in the continuous typing effect
          console.log("Erase text function is obsolete");
        };
        
        // Show the final display (both heading and subheadline together)
        const showFinalDisplay = () => {
          // Instead of replacing the content completely, let's maintain the same styling
          // and just add the line break between heading and subheading
          
          // Add a line break between the heading and subheading
          // We'll maintain the same font size for consistency
          
          // First, extract what we've typed so far
          const currentContent = contentElement.textContent || '';
          
          // Split the content at the appropriate point
          // The heading is the first part of the sequence
          const headingPart = finalHeading;
          const subheadingPart = finalSubheading;
          
          // Format the final display with line break but keep the same text size for subheading
          contentElement.innerHTML = `${headingPart}<br>${subheadingPart}`;
          
          // Update ARIA for screen readers
          activeContentElement.textContent = `Final display: ${headingPart}. ${subheadingPart}`;
          
          // Mark animation as complete
          animationComplete = true;
        };
        
        // Add keyboard interaction for accessibility
        containerElement.setAttribute('tabindex', '0');
        containerElement.addEventListener('keydown', (e) => {
          // Allow users to skip to final display with Enter key
          if (e.key === 'Enter' && !animationComplete) {
            e.preventDefault();
            showFinalDisplay();
          }
        });
        
        // Initial ARIA setup
        updateAriaLabel();
        
        // Start initial typing effect
        setTimeout(typeNextChar, 500);
      }
    });
  });
</script>

<style>
  .typewriter-cursor {
    font-weight: 400;
    width: 1px;
    animation: blink 0.7s infinite;
  }
  
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  .animate-fade-in {
    animation: fadeIn 0.5s ease-in-out forwards;
  }
  
  /* Hide content visually but keep it accessible to screen readers */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }
  
  /* Focus styles for keyboard interaction */
  .typewriter-container:focus {
    outline: 2px solid #4d90fe;
    outline-offset: 2px;
  }
  
  /* Remove focus outline for mouse users, but keep it for keyboard */
  .typewriter-container:focus:not(:focus-visible) {
    outline: none;
  }
  
  .typewriter-container:focus-visible {
    outline: 2px solid #4d90fe;
    outline-offset: 2px;
  }
  
  /* Styling for the final display */
  #final-display {
    transition: all 0.3s ease-in-out;
  }
  
  .typewriter-text {
    min-height: 4rem;
  }
</style>
